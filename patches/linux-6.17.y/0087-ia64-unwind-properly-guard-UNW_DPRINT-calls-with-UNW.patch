From 57fbffa4e8cf254b53de035948bed00252a6dbc2 Mon Sep 17 00:00:00 2001
From: Mingcong Bai <jeffbai@aosc.io>
Date: Sat, 6 Sep 2025 01:59:50 +0800
Subject: [PATCH 87/90] ia64: unwind: properly guard UNW_DPRINT calls with
 UNW_DEBUG

The original implementation relies on UNW_DPRINT being defined to null to
skip debug output (when UNW_DEBUG is not defined), which resulted in two
instances of empty else branches. In those two instances, when the else
brace is not surrounded by braces, it then triggered `-Werror=empty-body'.

Adding the braces, however, would not make the code any more sane, as
UNW_DEBUG is never defined in the build system. To rectify this, introduce
a Kconfig option named IA64_UNW_DEBUG, which, when enabled passes
-DUNW_DEBUG=0 to make this behaviour actually controllable (and consistent
with the original semantics).

Signed-off-by: Cyan <cyan@cyano.uk>
Signed-off-by: Mingcong Bai <jeffbai@aosc.io>
---
 arch/ia64/Kconfig         |   7 +++
 arch/ia64/kernel/Makefile |   2 +
 arch/ia64/kernel/unwind.c | 119 ++++++++++++++++++++++++++++++++++----
 3 files changed, 116 insertions(+), 12 deletions(-)

diff --git a/arch/ia64/Kconfig b/arch/ia64/Kconfig
index c24642643eb0..e840f5038626 100644
--- a/arch/ia64/Kconfig
+++ b/arch/ia64/Kconfig
@@ -398,3 +398,10 @@ config MSPEC
 	  If you have an ia64 and you want to enable memory special
 	  operations support (formerly known as fetchop), say Y here,
 	  otherwise say N.
+
+config IA64_UNW_DEBUG
+	bool "Enable IA-64 Unwind Debugging Output"
+	depends on IA64
+	help
+	  If you would like to enable debugging output for unwind, say Y here,
+	  otherwise say N.
diff --git a/arch/ia64/kernel/Makefile b/arch/ia64/kernel/Makefile
index d7e1cabee2ec..d67fa148f076 100644
--- a/arch/ia64/kernel/Makefile
+++ b/arch/ia64/kernel/Makefile
@@ -39,6 +39,8 @@ obj-$(CONFIG_INTEL_IOMMU)	+= pci-dma.o
 
 obj-$(CONFIG_ELF_CORE)		+= elfcore.o
 
+cflags-$(CONFIG_IA64_UNW_DEBUG)	+= -DUNW_DEBUG=0
+
 # fp_emulate() expects f2-f5,f16-f31 to contain the user-level state.
 CFLAGS_traps.o  += -mfixed-range=f2-f5,f16-f31
 
diff --git a/arch/ia64/kernel/unwind.c b/arch/ia64/kernel/unwind.c
index f8b835919516..f714a10fbd28 100644
--- a/arch/ia64/kernel/unwind.c
+++ b/arch/ia64/kernel/unwind.c
@@ -56,16 +56,15 @@
 #define UNW_STATS	0	/* WARNING: this disabled interrupts for long time-spans!! */
 
 #ifdef UNW_DEBUG
-  static unsigned int unw_debug_level = UNW_DEBUG;
-#  define UNW_DEBUG_ON(n)	unw_debug_level >= n
-   /* Do not code a printk level, not all debug lines end in newline */
-#  define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
-#  undef inline
-#  define inline
-#else /* !UNW_DEBUG */
-#  define UNW_DEBUG_ON(n)  0
-#  define UNW_DPRINT(n, ...)
-#endif /* UNW_DEBUG */
+static unsigned int unw_debug_level = UNW_DEBUG;
+#define UNW_DEBUG_ON(n)	unw_debug_level >= n
+#else
+#define UNW_DEBUG_ON(n)	1
+#endif
+/* Do not code a printk level, not all debug lines end in newline */
+#define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
+#undef inline
+#define inline
 
 #if UNW_STATS
 # define STAT(x...)	x
@@ -257,7 +256,9 @@ pt_regs_off (unsigned long reg)
 		off = unw.pt_regs_offsets[reg];
 
 	if (off < 0) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: bad scratch reg r%lu\n", __func__, reg);
+#endif
 		off = 0;
 	}
 	return (unsigned long) off;
@@ -268,13 +269,17 @@ get_scratch_regs (struct unw_frame_info *info)
 {
 	if (!info->pt) {
 		/* This should not happen with valid unwind info.  */
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: bad unwind info: resetting info->pt\n", __func__);
+#endif
 		if (info->flags & UNW_FLAG_INTERRUPT_FRAME)
 			info->pt = (unsigned long) ((struct pt_regs *) info->psp - 1);
 		else
 			info->pt = info->sp - 16;
 	}
+#ifdef UNW_DEBUG
 	UNW_DPRINT(3, "unwind.%s: sp 0x%lx pt 0x%lx\n", __func__, info->sp, info->pt);
+#endif
 	return (struct pt_regs *) info->pt;
 }
 
@@ -293,8 +298,10 @@ unw_access_gr (struct unw_frame_info *info, int regnum, unsigned long *val, char
 			*nat = 0;
 			return 0;
 		}
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: trying to access non-existent r%u\n",
 			   __func__, regnum);
+#endif
 		return -1;
 	}
 
@@ -339,11 +346,13 @@ unw_access_gr (struct unw_frame_info *info, int regnum, unsigned long *val, char
 					if ((unsigned long) addr < info->regstk.limit
 					    || (unsigned long) addr >= info->regstk.top)
 					{
+#ifdef UNW_DEBUG
 						UNW_DPRINT(0, "unwind.%s: %p outside of regstk "
 							"[0x%lx-0x%lx)\n",
 							__func__, (void *) addr,
 							info->regstk.limit,
 							info->regstk.top);
+#endif
 						return -1;
 					}
 					if ((unsigned long) nat_addr >= info->regstk.top)
@@ -373,8 +382,10 @@ unw_access_gr (struct unw_frame_info *info, int regnum, unsigned long *val, char
 		if ((unsigned long) addr < info->regstk.limit
 		    || (unsigned long) addr >= info->regstk.top)
 		{
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: ignoring attempt to access register outside "
 				   "of rbs\n",  __func__);
+#endif
 			return -1;
 		}
 		if ((unsigned long) nat_addr >= info->regstk.top)
@@ -384,8 +395,10 @@ unw_access_gr (struct unw_frame_info *info, int regnum, unsigned long *val, char
 
 	if (write) {
 		if (read_only(addr)) {
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n",
 				__func__);
+#endif
 		} else {
 			*addr = *val;
 			if (*nat)
@@ -426,14 +439,18 @@ unw_access_br (struct unw_frame_info *info, int regnum, unsigned long *val, int
 		break;
 
 	      default:
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: trying to access non-existent b%u\n",
 			   __func__, regnum);
+#endif
 		return -1;
 	}
 	if (write)
 		if (read_only(addr)) {
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n",
 				__func__);
+#endif
 		} else
 			*addr = *val;
 	else
@@ -449,8 +466,10 @@ unw_access_fr (struct unw_frame_info *info, int regnum, struct ia64_fpreg *val,
 	struct pt_regs *pt;
 
 	if ((unsigned) (regnum - 2) >= 126) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: trying to access non-existent f%u\n",
 			   __func__, regnum);
+#endif
 		return -1;
 	}
 
@@ -481,8 +500,10 @@ unw_access_fr (struct unw_frame_info *info, int regnum, struct ia64_fpreg *val,
 
 	if (write)
 		if (read_only(addr)) {
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n",
 				__func__);
+#endif
 		} else
 			*addr = *val;
 	else
@@ -571,15 +592,19 @@ unw_access_ar (struct unw_frame_info *info, int regnum, unsigned long *val, int
 		break;
 
 	      default:
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: trying to access non-existent ar%u\n",
 			   __func__, regnum);
+#endif
 		return -1;
 	}
 
 	if (write) {
 		if (read_only(addr)) {
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n",
 				__func__);
+#endif
 		} else
 			*addr = *val;
 	} else
@@ -599,8 +624,10 @@ unw_access_pr (struct unw_frame_info *info, unsigned long *val, int write)
 
 	if (write) {
 		if (read_only(addr)) {
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n",
 				__func__);
+#endif
 		} else
 			*addr = *val;
 	} else
@@ -699,7 +726,9 @@ decode_abreg (unsigned char abreg, int memory)
 	      default:
 		break;
 	}
+#ifdef UNW_DEBUG
 	UNW_DPRINT(0, "unwind.%s: bad abreg=0x%x\n", __func__, abreg);
+#endif
 	return UNW_REG_LC;
 }
 
@@ -739,7 +768,9 @@ spill_next_when (struct unw_reg_info **regp, struct unw_reg_info *lim, unw_word
 			return;
 		}
 	}
+#ifdef UNW_DEBUG
 	UNW_DPRINT(0, "unwind.%s: excess spill!\n",  __func__);
+#endif
 }
 
 static inline void
@@ -855,11 +886,16 @@ desc_abi (unsigned char abi, unsigned char context, struct unw_state_record *sr)
 {
 	if (abi == 3 && context == 'i') {
 		sr->flags |= UNW_FLAG_INTERRUPT_FRAME;
+#ifdef UNW_DEBUG
 		UNW_DPRINT(3, "unwind.%s: interrupt frame\n",  __func__);
+#endif
 	}
-	else
+	else {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind%s: ignoring unwabi(abi=0x%x,context=0x%x)\n",
 				__func__, abi, context);
+#endif
+	}
 }
 
 static inline void
@@ -1346,8 +1382,10 @@ static inline void
 script_emit (struct unw_script *script, struct unw_insn insn)
 {
 	if (script->count >= UNW_MAX_SCRIPT_LEN) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: script exceeds maximum size of %u instructions!\n",
 			__func__, UNW_MAX_SCRIPT_LEN);
+#endif
 		return;
 	}
 	script->insn[script->count++] = insn;
@@ -1388,8 +1426,10 @@ emit_nat_info (struct unw_state_record *sr, int i, struct unw_script *script)
 		break;
 
 	      default:
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: don't know how to emit nat info for where = %u\n",
 			   __func__, r->where);
+#endif
 		return;
 	}
 	insn.opc = opc;
@@ -1444,9 +1484,12 @@ compile_reg (struct unw_state_record *sr, int i, struct unw_script *script)
 			opc = UNW_INSN_MOVE_SCRATCH;
 			if (rval <= 11)
 				val = offsetof(struct pt_regs, f6) + 16*(rval - 6);
-			else
+			else {
+#ifdef UNW_DEBUG
 				UNW_DPRINT(0, "unwind.%s: kernel may not touch f%lu\n",
 					   __func__, rval);
+#endif
+			}
 		}
 		break;
 
@@ -1473,8 +1516,10 @@ compile_reg (struct unw_state_record *sr, int i, struct unw_script *script)
 		break;
 
 	      default:
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind%s: register %u has unexpected `where' value of %u\n",
 			   __func__, i, r->where);
+#endif
 		break;
 	}
 	insn.opc = opc;
@@ -1547,10 +1592,14 @@ build_script (struct unw_frame_info *info)
 		r->when = UNW_WHEN_NEVER;
 	sr.pr_val = info->pr;
 
+#ifdef UNW_DEBUG
 	UNW_DPRINT(3, "unwind.%s: ip 0x%lx\n", __func__, ip);
+#endif
 	script = script_new(ip);
 	if (!script) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: failed to create unwind script\n",  __func__);
+#endif
 		STAT(unw.stat.script.build_time += ia64_get_itc() - start);
 		return NULL;
 	}
@@ -1583,8 +1632,10 @@ build_script (struct unw_frame_info *info)
 	}
 	if (!e) {
 		/* no info, return default unwinder (leaf proc, no mem stack, no saved regs)  */
+#ifdef UNW_DEBUG
 		UNW_DPRINT(1, "unwind.%s: no unwind info for ip=0x%lx (prev ip=0x%lx)\n",
 			__func__, ip, unw.cache[info->prev_script].ip);
+#endif
 		sr.curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
 		sr.curr.reg[UNW_REG_RP].when = -1;
 		sr.curr.reg[UNW_REG_RP].val = 0;
@@ -1632,9 +1683,11 @@ build_script (struct unw_frame_info *info)
 		sr.curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;
 		sr.curr.reg[UNW_REG_RP].when = -1;
 		sr.curr.reg[UNW_REG_RP].val = sr.return_link_reg;
+#ifdef UNW_DEBUG
 		UNW_DPRINT(1, "unwind.%s: using default for rp at ip=0x%lx where=%d val=0x%lx\n",
 			   __func__, ip, sr.curr.reg[UNW_REG_RP].where,
 			   sr.curr.reg[UNW_REG_RP].val);
+#endif
 	}
 
 #ifdef UNW_DEBUG
@@ -1760,8 +1813,10 @@ run_script (struct unw_script *script, struct unw_frame_info *state)
 				s[dst] = (unsigned long) get_scratch_regs(state) + val;
 			} else {
 				s[dst] = 0;
+#ifdef UNW_DEBUG
 				UNW_DPRINT(0, "unwind.%s: no state->pt, dst=%ld, val=%ld\n",
 					   __func__, dst, val);
+#endif
 			}
 			break;
 
@@ -1770,8 +1825,10 @@ run_script (struct unw_script *script, struct unw_frame_info *state)
 				s[dst] = (unsigned long) &unw.r0;
 			else {
 				s[dst] = 0;
+#ifdef UNW_DEBUG
 				UNW_DPRINT(0, "unwind.%s: UNW_INSN_MOVE_CONST bad val=%ld\n",
 					   __func__, val);
+#endif
 			}
 			break;
 
@@ -1840,7 +1897,9 @@ find_save_locs (struct unw_frame_info *info)
 	if ((info->ip & (local_cpu_data->unimpl_va_mask | 0xf)) || info->ip < TASK_SIZE) {
 		/* don't let obviously bad addresses pollute the cache */
 		/* FIXME: should really be level 0 but it occurs too often. KAO */
+#ifdef UNW_DEBUG
 		UNW_DPRINT(1, "unwind.%s: rejecting bad ip=0x%lx\n", __func__, info->ip);
+#endif
 		info->rp_loc = NULL;
 		return -1;
 	}
@@ -1851,9 +1910,11 @@ find_save_locs (struct unw_frame_info *info)
 		scr = build_script(info);
 		if (!scr) {
 			spin_unlock_irqrestore(&unw.lock, flags);
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0,
 				   "unwind.%s: failed to locate/build unwind script for ip %lx\n",
 				   __func__, info->ip);
+#endif
 			return -1;
 		}
 		have_write_lock = 1;
@@ -1896,22 +1957,28 @@ unw_unwind (struct unw_frame_info *info)
 	/* validate the return IP pointer */
 	if (!unw_valid(info, info->rp_loc)) {
 		/* FIXME: should really be level 0 but it occurs too often. KAO */
+#ifdef UNW_DEBUG
 		UNW_DPRINT(1, "unwind.%s: failed to locate return link (ip=0x%lx)!\n",
 			   __func__, info->ip);
+#endif
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
 	/* restore the ip */
 	ip = info->ip = *info->rp_loc;
 	if (ip < GATE_ADDR) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(2, "unwind.%s: reached user-space (ip=0x%lx)\n", __func__, ip);
+#endif
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
 
 	/* validate the previous stack frame pointer */
 	if (!unw_valid(info, info->pfs_loc)) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: failed to locate ar.pfs!\n", __func__);
+#endif
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
@@ -1927,13 +1994,17 @@ unw_unwind (struct unw_frame_info *info)
 			num_regs = *info->cfm_loc & 0x7f;		/* size of frame */
 		info->pfs_loc =
 			(unsigned long *) (info->pt + offsetof(struct pt_regs, ar_pfs));
+#ifdef UNW_DEBUG
 		UNW_DPRINT(3, "unwind.%s: interrupt_frame pt 0x%lx\n", __func__, info->pt);
+#endif
 	} else
 		num_regs = (*info->cfm_loc >> 7) & 0x7f;	/* size of locals */
 	info->bsp = (unsigned long) ia64_rse_skip_regs((unsigned long *) info->bsp, -num_regs);
 	if (info->bsp < info->regstk.limit || info->bsp > info->regstk.top) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: bsp (0x%lx) out of range [0x%lx-0x%lx]\n",
 			__func__, info->bsp, info->regstk.limit, info->regstk.top);
+#endif
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
@@ -1941,15 +2012,19 @@ unw_unwind (struct unw_frame_info *info)
 	/* restore the sp: */
 	info->sp = info->psp;
 	if (info->sp < info->memstk.top || info->sp > info->memstk.limit) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: sp (0x%lx) out of range [0x%lx-0x%lx]\n",
 			__func__, info->sp, info->memstk.top, info->memstk.limit);
+#endif
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
 
 	if (info->ip == prev_ip && info->sp == prev_sp && info->bsp == prev_bsp) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: ip, sp, bsp unchanged; stopping here (ip=0x%lx)\n",
 			   __func__, ip);
+#endif
 		STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 		return -1;
 	}
@@ -1975,8 +2050,10 @@ unw_unwind_to_user (struct unw_frame_info *info)
 		unw_get_sp(info, &sp);
 		if ((long)((unsigned long)info->task + IA64_STK_OFFSET - sp)
 		    < IA64_PT_REGS_SIZE) {
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: ran off the top of the kernel stack\n",
 				   __func__);
+#endif
 			break;
 		}
 		if (unw_is_intr_frame(info) &&
@@ -1984,15 +2061,19 @@ unw_unwind_to_user (struct unw_frame_info *info)
 			return 0;
 		if (unw_get_pr (info, &pr) < 0) {
 			unw_get_rp(info, &ip);
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: failed to read "
 				   "predicate register (ip=0x%lx)\n",
 				__func__, ip);
+#endif
 			return -1;
 		}
 	} while (unw_unwind(info) >= 0);
 	unw_get_ip(info, &ip);
+#ifdef UNW_DEBUG
 	UNW_DPRINT(0, "unwind.%s: failed to unwind to user-level (ip=0x%lx)\n",
 		   __func__, ip);
+#endif
 	return -1;
 }
 EXPORT_SYMBOL(unw_unwind_to_user);
@@ -2036,6 +2117,7 @@ init_frame_info (struct unw_frame_info *info, struct task_struct *t,
 	info->sw  = sw;
 	info->sp = info->psp = stktop;
 	info->pr = sw->pr;
+#ifdef UNW_DEBUG
 	UNW_DPRINT(3, "unwind.%s:\n"
 		   "  task   0x%lx\n"
 		   "  rbs = [0x%lx-0x%lx)\n"
@@ -2045,6 +2127,7 @@ init_frame_info (struct unw_frame_info *info, struct task_struct *t,
 		   "  sp     0x%lx\n",
 		   __func__, (unsigned long) t, rbslimit, rbstop, stktop, stklimit,
 		   info->pr, (unsigned long) info->sw, info->sp);
+#endif
 	STAT(unw.stat.api.init_time += ia64_get_itc() - start; local_irq_restore(flags));
 }
 
@@ -2058,11 +2141,13 @@ unw_init_frame_info (struct unw_frame_info *info, struct task_struct *t, struct
 	sol = (*info->cfm_loc >> 7) & 0x7f;
 	info->bsp = (unsigned long) ia64_rse_skip_regs((unsigned long *) info->regstk.top, -sol);
 	info->ip = sw->b0;
+#ifdef UNW_DEBUG
 	UNW_DPRINT(3, "unwind.%s:\n"
 		   "  bsp    0x%lx\n"
 		   "  sol    0x%lx\n"
 		   "  ip     0x%lx\n",
 		   __func__, info->bsp, sol, info->ip);
+#endif
 	find_save_locs(info);
 }
 
@@ -2073,7 +2158,9 @@ unw_init_from_blocked_task (struct unw_frame_info *info, struct task_struct *t)
 {
 	struct switch_stack *sw = (struct switch_stack *) (t->thread.ksp + 16);
 
+#ifdef UNW_DEBUG
 	UNW_DPRINT(1, "unwind.%s\n", __func__);
+#endif
 	unw_init_frame_info(info, t, sw);
 }
 EXPORT_SYMBOL(unw_init_from_blocked_task);
@@ -2102,8 +2189,10 @@ unw_add_unwind_table (const char *name, unsigned long segment_base, unsigned lon
 	unsigned long flags;
 
 	if (end - start <= 0) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: ignoring attempt to insert empty unwind table\n",
 			   __func__);
+#endif
 		return NULL;
 	}
 
@@ -2133,15 +2222,19 @@ unw_remove_unwind_table (void *handle)
 	long index;
 
 	if (!handle) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: ignoring attempt to remove non-existent unwind table\n",
 			   __func__);
+#endif
 		return;
 	}
 
 	table = handle;
 	if (table == &unw.kernel_table) {
+#ifdef UNW_DEBUG
 		UNW_DPRINT(0, "unwind.%s: sorry, freeing the kernel's unwind table is a "
 			   "no-can-do!\n", __func__);
+#endif
 		return;
 	}
 
@@ -2153,8 +2246,10 @@ unw_remove_unwind_table (void *handle)
 			if (prev->next == table)
 				break;
 		if (!prev) {
+#ifdef UNW_DEBUG
 			UNW_DPRINT(0, "unwind.%s: failed to find unwind table %p\n",
 				   __func__, (void *) table);
+#endif
 			spin_unlock_irqrestore(&unw.lock, flags);
 			return;
 		}
-- 
2.25.1

